# 学习笔记

### 总体学习状况

​		这是算法提高班的第一周，总体上说学习状况还可以，这周一共刷了16到题，感觉从最开始的看见题目的一脸懵逼，到现在手不抖了，确实思维上有了不少的提高。至少现在看见题目会开始会懂得画关键词了，比如有序的，整数，非负的，参数范围等等，这样能减少解决问题的答案的搜索范围。同时随着刷题数量和类型的提升，一些解决方案的模型确实开始有一些模糊的印象了，比如利用hash表来达到空间换时间的目的，利用排序来减低时间复杂度，利用双指针来分组等等。当然这些目前都还处于很初级的阶段，还需要多多练习才行。

​		本来学习日志，是想着重介绍某个知识点的，比如递归，自己还刻意回去翻了一下以前大学的算法教科书，发现完全看不懂了，因此觉得目前自己还没能力对某个知识点进行相对深入的介绍，所以干脆就这种刷的题目来记录一下做题的过程和自己的一些想法和总结，当然这些题目中他们往往在解题方法和思路有一些交叉，所以我挑一些自己印象深刻的题来记录。希望自己之后能有所提升，能对某个内容写出较为深刻点的文章。

### 双指针

双指针是我这周学习，碰到表较多，印象也比较深刻的解题方法之一。就个人所刷的一些题来说，最归类下面几个用法：

#### 1. 分类

##### 	例子题目：移动零

> ​	给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
>
> ​	示例:  输入: [0,1,0,3,12] 输出: [1,3,12,0,0] 
> ​	说明: 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。

这道题是我在leetcode上面刷的题第一题，关键实我当时没有做出来/(ㄒoㄒ)/~~，我当时的思路是想先把0删了，再在后面补0，就每次找到连续的0（假如n个），就把这些0后面的数组元素往前移动n位，但是时间复杂度一直不能通过测试，也死磕了一会。。。最后看答案。

```java
for (int i = 0, j = 0; i < nums.length;i++){
    if(nums[i] != 0){
        if(i != j)
        {
            nums[j] = nums[i];
            nums[i] = 0;
        }
        j++;
    }
}
```

这题就是把数据分为两类，一种是0，一种是非0，如果一个指针指定了0的位置，另外一个指针在遍历的时候，只要把不是0不断和第一个0交换位置，0自然就“沉”到后面去了。

#### 2. 夹逼法

我目前对其的理解就是通过两边的游标不断的对比来确定收缩的方向，直到相遇。但是还不是很了解什么情况下适合这种算法，或者我用这种算法的时候，怎么判断它不会漏掉结果，这是之后要去了解的。

##### 例子题目：三数之和

> 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。
>
> 注意：答案中不可以包含重复的三元组。
>

这道题目是老师视频里面提到个的一条题目，同样还有一道用到夹逼法题目《盛最多水的容器》，但就我个人理解来说，这条题目对夹逼法特征理解的更加清晰一点。

下面是论坛上面找出的最优答案，从这里可以看出能使用夹逼法的前提往往是必须是有序的。

```java
public List<List<Integer>> threeSum(int[] nums) {
    if (nums == null || nums.length < 3) {
        return Collections.emptyList();
    }
    List<List<Integer>> result = new ArrayList<>();
    Arrays.sort(nums);
    for (int k = 0; k < nums.length - 2; k++) {
        if (nums[k] > 0) {
            break;
        }
        if(k > 0 && nums[k] == nums[k - 1]){
            continue;
        }
        int i = k + 1;
        int j = nums.length - 1;
        while ( i < j) {
            int sum = nums[k] + nums[i] + nums[j];
            if (sum == 0) {
                result.add(Arrays.asList(nums[k], nums[i], nums[j]));
                while (i < j && nums[i++] == nums[i]) ;
                while (j > i && nums[j--] == nums[j]) ;
            } else if (sum < 0) {
                while (i < j && nums[i++] == nums[i]) ;
            } else {
                while (j > i && nums[j--] == nums[j]) ;
            }
        }
    }
    return result;
}
```



### 空间换时间-hansh表

就这周的学习而言，目前接触到的用的比价多空间换时间就是hash表。

##### 例子题目：两数之和

> 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
>
> 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。



这道题也是老师视频上面讲过的题目，但是我第一次做这道题的时候，还没看到老师这视频，所以我第一次做的答案相对来说比较丑陋。

这是我第一次答案的代码。由于我做这题目时候，接触了一些排序和夹逼法对时间复杂度的题目，所以下意识就往这题目上面套了，通过排序和夹逼法来减低时间复杂度。

```java
public int[] twoSum(int[] nums, int target) {
    int[] newArray = new int[nums.length];
    // 拷贝一个新数组
    System.arraycopy(nums, 0, newArray, 0, nums.length);
    // 对新数组排序
    Arrays.sort(newArray);
    int i = 0;
    int j = 0;
    for (i = 0, j = newArray.length - 1; i < j; )
    {
        // 利用夹逼法在新数组中找出两个元素的和是target的下标
        ...
    }
    
    int[] result = new int[]{-1, -1};
    for (int k = 0; k < nums.length; k++)
    {
        //找出newArray[i]和newArray[j]在久数组中的下标
        ...
    }
    return result;
}
```

再来看官方的最优答案

```java
public int[] twoSum(int[] nums, int target) {
    Map<Integer,Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        int c = target - nums[i];
        if(map.containsKey(c)){
            return new int[]{map.get(c),i};
        }else {
            map.put(nums[i],i);
        }
    }
    throw new RuntimeException("no tow elemnt sum = " + target);
}
```

官方就是通过hash表来减低赋值度的，所用的空间复杂度和我上面的一样，但是少了一步回旧数组寻找下标的步骤，可以直接通过hash表来获取，当然其他存hash表的过程也优化了，所以代码更少更快。



### 有时候可以从另一个角度去考虑解决方法

##### 例子题目：两数之和

还是上面题目两数之和，在第一种解法中，我是定势的从a + b = target来考虑问题，所以想两类相加判断是等于target，但是也可以把公式写成target - b = a，再结合hash表，解题思路就完全不一样了，所以题目中的公司，可以多换几个写法来看，说不定会用不一样的思路。

##### 例子题目：移动零

最开始提到的例子移动零，一开始我就想着如何把0往后移动，但是这道题目是你可以不把焦点放在0上面，你只要把非0数字按照顺序一个个替换掉最前面的0，0自然就“沉”下去了。

如果桶里面有红球和白球，你要挑出红球，你可以直接把红球一个个拿出来，也可以把白球一个个拿出来，剩下就是红球了。











